export function chonk(input,chunkSize){if(null==input||+chunkSize<1)throw Error("Invalid input");if("string"==typeof input){if(!input.length)return[];let characters=Intl?.Segmenter?Array.from(new Intl.Segmenter(0,{granularity:"grapheme"}).segment(input),(segment=>segment.segment)):Array.from(input),result=[];for(let index=0;index<characters.length;index+=chunkSize)result.push(characters.slice(index,index+chunkSize).join(""));return result}if(Array.isArray(input)||ArrayBuffer.isView(input)){if(!input.length)return[];let result=[];for(let index=0;index<input.length;index+=chunkSize)result.push(input.slice(index,index+chunkSize));return result}if("object"==typeof input){try{if(input[Symbol.iterator])return chonk([...input],chunkSize)}catch(error){}if(input&&+input.length>-1){if(!input.length)return[];let array=[];for(let index=0;index<input.length;index++)array[index]=input[index];return chonk(array,chunkSize)}}throw Error("Invalid type")}export async function*chonkAsync(asyncInput,chunkSize){if(null==asyncInput||+chunkSize<1||!asyncInput[Symbol.asyncIterator])throw Error("Invalid input");let buffer=[];for await(const item of asyncInput)buffer.push(item),buffer.length>=chunkSize&&(yield buffer,buffer=[]);buffer.length&&(yield buffer)}