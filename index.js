export function chonk(r,t){if(null==r||+t<1)throw Error("Invalid input");if("string"==typeof r){if(!r.length)return[];let e=Array.from(r),n=[];for(let r=0;r<e.length;r+=t)n.push(e.slice(r,r+t).join(""));return n}if(Array.isArray(r)||ArrayBuffer.isView(r)){if(!r.length)return[];let e=[];for(let n=0;n<r.length;n+=t)e.push(r.slice(n,n+t));return e}if("object"==typeof r){try{if(r[Symbol.iterator])return chonk([...r],t)}catch(r){}if(r&&+r.length>-1){if(!r.length)return[];let e=[];for(let t=0;t<r.length;t++)e[t]=r[t];return chonk(e,t)}}throw Error("Invalid type")}export function chonkGraphemes(r,t){if("string"!=typeof r)return chonk(r,t);if(null==r||+t<1)throw Error("Invalid input");if(!r.length)return[];let e=Intl?.Segmenter?Array.from(new Intl.Segmenter(0,{granularity:"grapheme"}).segment(r),(r=>r.segment)):Array.from(r),n=[];for(let r=0;r<e.length;r+=t)n.push(e.slice(r,r+t).join(""));return n}export async function*chonkAsync(r,t){if(null==r||+t<1||!r[Symbol.asyncIterator])throw Error("Invalid input");let e=[];for await(const n of r)e.push(n),e.length>=t&&(yield e,e=[]);e.length&&(yield e)}